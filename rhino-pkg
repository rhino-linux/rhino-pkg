#!/usr/bin/env nu
def translation-dir-path [] -> string {
    "this/is/the/path/to/translation"
}
def cmd-exist [input: string] -> bool {
    let stuff = (which $input)
    if ($stuff | is-empty) { return false } else if ($stuff).type.0 == "external" { return true }
}

def search-apt [input: string, desc: bool] -> table {
    if (cmd-exist 'apt-cache') {
        if $desc == true {
            return (^apt-cache search $input | lines | parse "{package} - {description}" | insert provider 'apt')
        } else {
            return (^apt-cache search --names-only $input | lines | parse "{package} - {description}" | insert provider 'apt')
        }
    } else { return [] }
}

def search-pacstall [input: string] -> table {
    if (cmd-exist 'pacstall') {
        return (^pacstall -S $input | ansi strip | lines | parse "{package} @ {repo}" | reject repo | insert description '' | insert provider 'pacstall')
    } else { return [] }
}

def search-flatpak [input: string, desc: bool] -> table {
    if (cmd-exist 'flatpak') {
        if $desc == true {
            let flatpak = (^flatpak search $input --columns=application | lines | wrap 'package' | insert provider 'flatpak' | merge (^flatpak search $input --columns=description | lines | wrap 'description')) 
            if ($flatpak.package.0 == "No matches found") { return [] } else { return $flatpak }
        } else {
            let flatpak = (^flatpak search $input --columns=application | lines | wrap 'package' | insert provider 'flatpak' | insert description '') 
            if ($flatpak.package.0 == "No matches found") { return [] } else { return $flatpak }
        }
    } else { return [] }
}

def search-snap [input: string] -> table {
    if (cmd-exist 'snap') {
        return (^snap search $input | detect columns | get Name | wrap 'package' | insert description '' | insert provider 'flatpak')
    } else { return [] }
}

def search [input: string, searching: bool = true, desc: bool = false, install: bool = false] {
    translation-dir-path | translate searching.apt | print
    # print "Searching apt…"
    let apt = (search-apt $input $desc)
    print -n $"\e[A\e[K"
    # print "Searching Pacstall…"
    translation-dir-path | translate searching.pacstall | print
    let pacstall = (search-pacstall $input)
    print -n $"\e[A\e[K"
    # print "Searching flatpak…"
    translation-dir-path | translate searching.flatpak | print
    let flatpak = (search-flatpak $input $desc)
    print -n $"\e[A\e[K"
    # print "Searching snap…"
    translation-dir-path | translate searching.snap | print
    let snap = (search-snap $input)
    print -n $"\e[A\e[K"

    let results = ($flatpak | append $apt | append $pacstall | append $snap)

    # print -n $"\e[A\e[K"
    if ($results | is-empty) {
        # print -e $"No packages found matching '($input)'!"
        translation-dir-path | translate none-matching {search: $input } | print
        exit 1
    }
    let results_len = $results | length

    translation-dir-path | translate found-matching {matches: $results_len, search: $input} | print
   # print $"Found packages matching '(ansi purple_bold)($input)(ansi reset)':\n"

    mut count = 0
    # Loop over results
    for $i in $results {
        let style = match $i.provider {
            "pacstall" => "yellow_bold",
            "apt" => "green_bold",
            "flatpak" => "cyan_bold",
            "snap" => "red_bold",
            _ => "white_bold",
        }
        if $desc {
            if ($i.description | is-empty) {
                print $"[(ansi $style)($count)(ansi reset)]: ($i.package) \((ansi $style)($i.provider)(ansi reset)\)"
            } else {
                print $"[(ansi $style)($count)(ansi reset)]: ($i.package) (ansi white_bold)»|«(ansi reset) ($i.description) \((ansi $style)($i.provider)(ansi reset)\)"
            }
        } else {
            print $"[(ansi $style)($count)(ansi reset)]: ($i.package) \((ansi $style)($i.provider)(ansi reset)\)"
        }
        $count += 1
    }
    if $searching {
        return
    }
    if $install {
        # To the install now!
        install $results true
    } else {
        # Remove
        install $results false
    }
}

def cleanup [promptless: bool = false] {
    if (cmd-exist 'nala') {
        ^sudo nala install --fix-broken
        if $promptless {
            ^sudo nala autoremove -y
        } else {
            ^sudo nala autoremove
        }
    } else {
        ^sudo apt --fix-broken install
        if $promptless { ^sudo apt auto-remove -y } else { ^sudo apt auto-remove }
    }
    if (cmd-exist 'flatpak') {
        ^sudo flatpak repair
        if $promptless { ^sudo flatpak uninstall --unused -y } else { ^sudo flatpak uninstall --unused }
    }
    if (cmd-exist 'snap') {
        let snaps = (^snap list --all | detect columns)
        for $pkg in $snaps {
            if ($pkg.Notes) =~ "disabled" {
                ^sudo snap remove $pkg.Name --revision=$pkg.Rev
            }
        }
    }
}

def update [promptless: bool = false] {
    
    let r_u_sure = translation-dir-path| translate ask.upgrade 
    let sure = (input $"($r_u_sure) \((ansi green_bold)y(ansi reset)/(ansi red_bold)N(ansi reset)\)")
    # let sure = (input $"Are you sure you want to update all packages? \((ansi green_bold)y(ansi reset)/(ansi red_bold)N(ansi reset)\) ")
    if (!($sure | str starts-with -i "Y")) and (!($sure | str starts-with -i "y")) {
        exit 1
    } 
    
    if (cmd-exist 'nala') {
        if $promptless {
            ^sudo nala upgrade --full --no-autoremove -o Acquire::AllowReleaseInfoChange="true" -y
        } else {
            ^sudo nala upgrade --full --no-autoremove -o Acquire::AllowReleaseInfoChange="true"
        }
    } else {
        ^sudo apt update --allow-releaseinfo-change
        if $promptless { ^sudo apt upgrade -y } else { ^sudo apt upgrade }
    }
    if (cmd-exist 'pacstall') {
        ^pacstall -U
        if $promptless { ^pacstall -PUp } else { ^pacstall -Up }
    }
    if (cmd-exist 'flatpak') {
        if $promptless { ^sudo flatpak update -y } else { ^sudo flatpak update }
    }
    if (cmd-exist 'snap') {
        ^sudo snap refresh
    }
}

def install [input: table, install: bool = true] {
    mut user_input = 1
    print ""
    let input_final_index = ($input | length) - 1

    if $install {
        $user_input = (input (translation-dir-path| translate ask.which-install {index: $input_final_index}) | into int)
        #$user_input = (input $"Select which package to install [0-(($input | length) - 1)]: " | into int)
    } else {
        $user_input = (input (translation-dir-path| translate ask.which-remove {index: $input_final_index}) | into int)
        #$user_input = (input $"Select which package to remove [0-(($input | length) - 1)]: " | into int)
    }
    if ($user_input > ($input_final_index)) {
        error make -u { msg: "Input length is longer than amount of packages", }
    }
    let pkg = ($input | get $user_input | get package)
    let provider = ($input | get $user_input | get provider)
    
    
    #print $"Selecting '(ansi purple_bold)($pkg)(ansi reset)' from package manager '(ansi purple_bold)($provider)(ansi reset)'"
    
    if $install {
        translation-dir-path | translate install-select {package: $pkg, manager: $provider } | print
    } else {
        translation-dir-path | translate remove-select {package: $pkg, manager: $provider } | print
    }


    let r_u_sure = translation-dir-path| translate ask.sure 
    let sure = (input $"($r_u_sure) \((ansi green_bold)y(ansi reset)/(ansi red_bold)N(ansi reset)\)")
    
    
    # let sure = (input $"Are you sure? \((ansi green_bold)y(ansi reset)/(ansi red_bold)N(ansi reset)\) ")
    if (!($sure | str starts-with -i "Y")) and (!($sure | str starts-with -i "y")) {
        exit 1
    }

    if $install {
        match ($provider) {
            "pacstall" => (^pacstall -I $pkg),
            "snap" => (^sudo snap install $pkg),
            "apt" => (^sudo apt install $pkg -y),
            "flatpak" => (^sudo flatpak install $pkg -y),
        }
    } else {
        match ($provider) {
            "pacstall" => (^pacstall -R $pkg),
            "snap" => (^sudo snap remove $pkg),
            "apt" => (^sudo apt remove $pkg -y),
            "flatpak" => (^sudo flatpak remove $pkg -y),
        }
    }
}

# USAGE: rpk [function] {flag} <input>
# 
# functions:
#     install: Install package(s) - Prompts user to respond with
#              the number(s) associated with the desired package(s).
# 
#     remove:  Uninstall package(s) - Prompts user to respond with
#              the number(s) associated with the desired package(s).
# 
#     search:  Search for package(s) - Does not have a second prompt.
# 
#     update:  Updates all packages accessible to the wrapper - does
#              not accept <input>, instead use install to update
#              individual packages. Has a confirmation prompt.
# 
#     cleanup: Attempts to repair broken dependencies and remove any
#              unused packages. Does not accept <input>, but has
#              a confirmation prompt.
# 
# flags:
#     --help/-h: Display this page
# 
#     --description/-d: By default, rpk will only display packages
#     that contain <input> within their name. Use this flag to increase
#     range and display packages with <input> in their description.
# 
#     -y: Makes functions with confirmation prompts run promptless.
# 
# input:
#     Provide a package name or description.
# 
# Example execution:
#     $ rpk install foobar
#     Found packages matching 'foobar':
# 
#     [0]: pyfoobar (apt)
#     [1]: foobarshell (apt)
#     [2]: foobar (flatpak)
#     [3]: foobar-web (snap)
#     [4]: foobar-bin (pacstall)
#     [5]: foobar-theme (pacstall)
# 
#     Select which package to install [0-5]: 3 4 5
#     Selecting 'foobar-web' from package manager 'snap'
#     Selecting 'foobar-bin' from package manager 'pacstall'
#     Selecting 'foobar-theme' from package manager 'pacstall'
#     Are you sure? (y/N)
#     [...]
# 
#        .;:;,.  .:
#     'coooooooo:oo.';.
#   ,oooooooooooooooo    ;
#  clllcccllloooooooo;c:'o
# .;';:::::::::cclooooooo'
# ''',::::::::::::::ccclc.
# .''';::::::::::l:::::::
#  '''',:::::::::kd.
#  .''''',;::ck:oW;
#    ''''''''kXOM.
#      .,,:dXMK
#        :k
# 
# rpk 0.1.2
# A package manager wrapper for Pacstall, APT, Flatpak and snap
# Developed by Elsie19 <elsie19@pm.me> for
# the Rhino Linux distribution.
def main [
    --description (-d) # Increase range and display packages with <input> in their description
    --yes (-y) # Makes functions with confirmation prompts run promptless
    ...rest: string # 'install', 'remove', 'search', 'update', 'cleanup'
] -> int {
    if ($rest | is-empty) {
        exit 1
    }
    if not $rest.0 in ['install' 'remove' 'search' 'update' 'cleanup'] {
        error make -u { msg: $"'($rest.0)' not a valid command", }
    }
    match $rest.0 {
        "install" => (search $rest.1 false $description true),
        "remove" => (search $rest.1 false $description false),
        "search" => (search $rest.1 true $description),
        "update" => (update $yes),
    }
}
