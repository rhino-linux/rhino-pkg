#!/usr/bin/env -S nu --plugins '[/usr/share/nutext/nu_plugin_nutext]'

use "/usr/share/rhino-pkg/modules/lib/" [search]
use "/usr/share/rhino-pkg/modules/pluggables/" [apt flatpak pacstall snap]
use "/usr/share/rhino-pkg/modules/lib/cmd.nu" [prompt cleanup-pkg remove-pkg]

tregister /usr/share/locale/ rhino-pkg

def main [
    --description (-d) # Increase range and display packages with <input> in their description
    --help (-h) # Display help page
    --yes (-y) # Makes functions with confirmation prompts run promptless
    ...rest: string # 'install', 'remove', 'search', 'update', 'cleanup', etc
] : any -> int {
    run-external $env.CURRENT_FILE help
    if ($rest | is-empty) {
        exit 1
    }
}

def "main --help" [] { main help }

def "main -h" [] { main help }

def "main help" [] {
    print $"USAGE: rpk [function] {flag} <input>

functions:
    install: Install package\(s\) - Prompts user to respond with
             the number\(s\) associated with the desired package\(s\).

    remove:  Uninstall package\(s\) - Prompts user to respond with
             the number\(s\) associated with the desired package\(s\).

    search:  Search for package\(s\) - Does not have a second prompt.

    update:  Updates all packages accessible to the wrapper - does
             not accept <input>, instead use install to update
             individual packages. Has a confirmation prompt.

    cleanup: Attempts to repair broken dependencies and remove any
             unused packages. Does not accept <input>, but has
             a confirmation prompt.

flags:
    --help/-h: Display this page

    --description/-d: By default, rpk will only display packages
    that contain <input> within their name. Use this flag to increase
    range and display packages with <input> in their description.

    -y: Makes functions with confirmation prompts run promptless.

input:
    Provide a package name or description.

Example execution:
    $ rpk install foobar
    Found packages matching '(ansi magenta_bold)foobar(ansi reset)':

    [(ansi green_bold)0(ansi reset)]: pyfoobar \((ansi green_bold)apt(ansi reset)\)
    [(ansi green_bold)1(ansi reset)]: foobarshell \((ansi green_bold)apt(ansi reset)\)
    [(ansi cyan_bold)2(ansi reset)]: foobar \((ansi cyan_bold)flatpak(ansi reset)\)
    [(ansi red_bold)3(ansi reset)]: foobar-web \((ansi red_bold)snap(ansi reset)\)
    [(ansi yellow_bold)4(ansi reset)]: foobar-bin \((ansi yellow_bold)pacstall(ansi reset)\)
    [(ansi yellow_bold)5(ansi reset)]: foobar-theme \((ansi yellow_bold)pacstall(ansi reset)\)

    Select which package to install [0-5]: 3 4 5
    Selecting '(ansi magenta_bold)foobar-web(ansi reset)' from package manager '(ansi magenta_bold)snap(ansi reset)'
    Selecting '(ansi magenta_bold)foobar-bin(ansi reset)' from package manager '(ansi magenta_bold)pacstall(ansi reset)'
    Selecting '(ansi magenta_bold)foobar-theme(ansi reset)' from package manager '(ansi magenta_bold)pacstall(ansi reset)'
    Are you sure? \((ansi green_bold)y(ansi reset)/(ansi red_bold)N(ansi reset)\)
    [...]

(ansi --escape '38;5;104m')       .;:;,.  .:
    'coooooooo:oo.';.
  ,oooooooooooooooo    ;
 clllcccllloooooooo;c:'o(ansi reset)
(ansi --escape '38;5;104m').(ansi reset)(ansi --escape '38;5;55m');(ansi --escape '38;5;98m')';:::::::::(ansi --escape '38;5;104m')cclooooooo'
(ansi --escape '38;5;55m')''',(ansi --escape '38;5;98m')::::::::::::::ccclc.
(ansi --escape '38;5;55m').'''(ansi --escape '38;5;98m');::::::::::(ansi reset)l(ansi --escape '38;5;98m'):::::::
 (ansi --escape '38;5;55m')''''(ansi --escape '38;5;98m'),:::::::::(ansi reset)kd(ansi --escape '38;5;98m').
 (ansi --escape '38;5;55m').'''''(ansi --escape '38;5;98m'),;::(ansi reset)ck:oW(ansi --escape '38;5;98m');
   (ansi --escape '38;5;55m')''''''''(ansi reset)kXOM.
     (ansi --escape '38;5;55m').,,:(ansi reset)dXMK
       :k

rpk 2.0.0
A package manager wrapper for Pacstall, APT, Flatpak and snap
Developed by Elsie19 <elsie19@pm.me> for
the Rhino Linux distribution."
}

def "main search" [
    --description (-d) # Increase range and display packages with <input> in their description
    rest: string # Search query
] {
    # Block output from `return` here.
    let dummy = (search search-pkgs $description $rest)
}

def "main install" [
    --description (-d) # Increase range and display packages with <input> in their description
    --yes (-y) # Makes functions with confirmation prompts run promptless
    rest: string # Search query
] {
    # Block output from `return` here.
    let dummy = (search search-pkgs $description $rest)
    if (($dummy | length) <= 0) {
        tprint -e "No packages found matching '{rest}'!" { rest: $rest }
        exit 1
    }
    let which = (prompt (_ "Select which packages to install") $dummy)
    $which | each {|part|
        tprint "Selecting '{pkg}' from package manager '{provider}'" {
            pkg: $"(ansi purple_bold)($part.pkg)(ansi reset)",
            provider: $"(ansi purple_bold)($part.provider)(ansi reset)"
        }
    }
    if not $yes {
        let response = (input (_ "Are you sure? ({y}/{n}) " {
                    y: $"(ansi green_bold)y(ansi reset)",
                    n: $"(ansi red_bold)N(ansi reset)" }
            )
        )
        if ($response | is-empty) or ($response | str downcase | str starts-with "n") {
            exit 1
        }
    }
    for part in $which {
        try {
            match $part.provider {
                "pacstall" => {
                    pacstall install $part $yes
                }
                "apt" => {
                    apt install $part.pkg $yes
                }
                "flatpak" => {
                    flatpak install $part $yes
                }
                "snap" => {
                    snap install $part
                }
            }
        } catch {
            tprint -e "Failed to install '{pkg}'." { pkg: $part.pkg }
            exit $env.LAST_EXIT_CODE
        }
    }
}

def "main remove" [
    --yes (-y) # Makes functions with confirmation prompts run promptless
    rest: string # Search query
] {
    # Block output from `return` here.
    let dummy = (search search-local-pkgs $rest)
    if (($dummy | length) <= 0) {
        tprint -e "No packages found matching '{rest}'!" { rest: $rest }
        return
    }
    let which = (prompt (_ "Select which package to remove") $dummy)
    for $part in $which {
        tprint -e "Removing '{part}' from '{provider}'" {
            part: $"(ansi purple_bold)($part.pkg)(ansi reset)",
            provider: $"(ansi purple_bold)($part.provider)(ansi reset)"
        }
        remove-pkg ($part | reject index) $yes
    }
}

def "main cleanup" [
    --yes (-y) # Makes functions with confirmation prompts run promptless
] {
    if not $yes {
        if not (input (_ "Attempting to repair dependencies and remove unused packages. Continue? ({y}/{n}) " {
                    y: $"(ansi green_bold)y(ansi reset)",
                    n: $"(ansi red_bold)N(ansi reset)"
                }
            )
                | str downcase
                | str starts-with "y") {
            exit 1
        }
    }
    cleanup-pkg $yes
}

def "main update" [
    --yes (-y) # Makes functions with confirmation prompts run promptless
] {
    if (not $yes) {
        let response = (input (_ "Are you sure you want to update all packages? ({y}/{n}) " {
                    y: $"(ansi green_bold)y(ansi reset)",
                    n: $"(ansi red_bold)N(ansi reset)"
                }
            ))
        if not ($response | str downcase | str starts-with "y") {
            exit 1
        }
    }
    apt upgrade $yes
    flatpak upgrade $yes
    pacstall upgrade $yes
    snap upgrade $yes
}
