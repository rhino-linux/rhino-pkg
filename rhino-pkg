#!/usr/bin/env -S nu --plugins '[/usr/share/nutext/nu_plugin_nutext]'

use "/usr/share/rhino-pkg/modules/lib/" [search]
use "/usr/share/rhino-pkg/modules/pluggables/" [apt flatpak pacstall snap]
use "/usr/share/rhino-pkg/modules/lib/cmd.nu" [prompt cleanup-pkg remove-pkg repo-sync]

tregister /usr/share/locale/ rhino-pkg

def main [
    --description (-d) # Increase range and display packages with <input> in their description
    --help (-h) # Display help page
    --yes (-y) # Makes functions with confirmation prompts run promptless
    ...rest: string # 'install', 'remove', 'search', 'update', 'cleanup', etc
] : any -> int {
    run-external $env.CURRENT_FILE help
    if ($rest | is-empty) {
        exit 1
    }
}

def "main --help" [] { main help }

def "main -h" [] { main help }

def "main help" [] {
    print $"USAGE: rpk [function] {flag} <input>

functions:
    install: Install package\(s\) - Prompts user to respond with
             the number\(s\) associated with the desired package\(s\).

    remove:  Uninstall package\(s\) - Prompts user to respond with
             the number\(s\) associated with the desired package\(s\).

    search:  Search for package\(s\) - Does not have a second prompt.

    update:  Updates all packages accessible to the wrapper - does
             not accept <input>, instead use install to update
             individual packages. Has a confirmation prompt.

    cleanup: Attempts to repair broken dependencies and remove any
             unused packages. Does not accept <input>, but has
             a confirmation prompt.

flags:
    --help/-h: Display this page

    --description/-d: By default, rpk will only display packages
    that contain <input> within their name. Use this flag to increase
    range and display packages with <input> in their description.

    -y: Makes functions with confirmation prompts run promptless.

input:
    Provide a package name or description.

(ansi --escape '38;5;104m')       .;:;,.  .:
    'coooooooo:oo.';.
  ,oooooooooooooooo    ;
 clllcccllloooooooo;c:'o(ansi reset)
(ansi --escape '38;5;104m').(ansi reset)(ansi --escape '38;5;55m');(ansi --escape '38;5;98m')';:::::::::(ansi --escape '38;5;104m')cclooooooo'
(ansi --escape '38;5;55m')''',(ansi --escape '38;5;98m')::::::::::::::ccclc.
(ansi --escape '38;5;55m').'''(ansi --escape '38;5;98m');::::::::::(ansi reset)l(ansi --escape '38;5;98m'):::::::
 (ansi --escape '38;5;55m')''''(ansi --escape '38;5;98m'),:::::::::(ansi reset)kd(ansi --escape '38;5;98m').
 (ansi --escape '38;5;55m').'''''(ansi --escape '38;5;98m'),;::(ansi reset)ck:oW(ansi --escape '38;5;98m');
   (ansi --escape '38;5;55m')''''''''(ansi reset)kXOM.
     (ansi --escape '38;5;55m').,,:(ansi reset)dXMK
       :k

rpk 2.0.0
A package manager wrapper for Pacstall, APT, Flatpak and snap
Developed by Elsie19 <elsie19@pm.me> for
the Rhino Linux distribution."
}

def "main s" [
    --description (-d)
    rest: string
] {
    if $description {
        main search $rest --description
    } else {
        main search $rest
    }
}

def "main sd" [
    rest: string
] { main search $rest --description }

def "main search" [
    --description (-d) # Increase range and display packages with <input> in their description
    rest: string # Search query
] {
    # Block output from `return` here.
    let dummy = (search search-pkgs $description $rest)
    if ($dummy | is-empty) {
        tprint -e "No packages found matching '{rest}'!" { rest: $rest }
        exit 1
    } else {
        if $description {
            return (
                $dummy
                | select index pkg provider desc
                | rename index Package Provider Description
            )
        } else {
            return (
                $dummy
                | select index pkg provider
                | rename index Package Provider
            )
        }
    }
}

def "main i" [
    --description (-d)
    --yes (-y)
    rest: string
] {
    if $description {
        if $yes {
            main install $rest --description --yes
        } else {
            main install $rest --description
        }
    } else {
        if $yes {
            main install $rest --yes
        } else {
            main install $rest
        }
    }
}

def "main id" [
    --yes (-y)
    rest: string
] {
    if $yes {
        main install $rest --description --yes
    } else {
        main install $rest --description
    }
}

def "main install" [
    --description (-d) # Increase range and display packages with <input> in their description
    --yes (-y) # Makes functions with confirmation prompts run promptless
    rest: string # Search query
] {
    # Block output from `return` here.
    let dummy = (search search-pkgs $description $rest)
    if ($dummy | is-empty) {
        tprint -e "No packages found matching '{rest}'!" { rest: $rest }
        exit 1
    } else {
        if $description {
            print (
                $dummy
                | select index pkg provider desc
                | rename index Package Provider Description
            )
        } else {
            print (
                $dummy
                | select index pkg provider
                | rename index Package Provider
            )
        }
    }
    let which = (prompt (_ "Select which packages to install") $dummy)
    $which | each {|part|
        tprint "Selecting '{pkg}' from package manager '{provider}'" {
            pkg: $"(ansi purple_bold)($part.pkg | ansi strip)(ansi reset)",
            provider: $"(ansi purple_bold)($part.provider | ansi strip)(ansi reset)"
        }
    }
    if not $yes {
        let response = (input (_ "Are you sure? ({y}/{n}) " {
                    y: $"(ansi green_bold)y(ansi reset)",
                    n: $"(ansi red_bold)N(ansi reset)" }
            )
        )
        if not ($response | str downcase | str starts-with "y") {
            exit 1
        }
    }
    for part in $which {
        try {
            match ($part.provider | ansi strip) {
                "apt" => {
                    apt install ($part.pkg | ansi strip) $yes
                }
                "pacstall" => {
                    pacstall install ($part.pkg | ansi strip) $part.repo $yes
                }
                "flatpak" => {
                    flatpak install ($part.pkg | ansi strip) $part.remote $yes
                }
                "snap" => {
                    snap install ($part.pkg | ansi strip) $part.notes
                }
            }
        } catch {
            tprint -e "Failed to install '{pkg}'." { pkg: $"(ansi red)($part.pkg | ansi strip)(ansi reset)" }
            exit $env.LAST_EXIT_CODE
        }
    }
}

def "main r" [
    --yes (-y)
    rest: string
] {
    if $yes {
        main remove $rest --yes
    } else {
        main remove $rest
    }
}

def "main rm" [
    --yes (-y)
    rest: string
] {
    if $yes {
        main remove $rest --yes
    } else {
        main remove $rest
    }
}

def "main remove" [
    --yes (-y) # Makes functions with confirmation prompts run promptless
    rest: string # Search query
] {
    # Block output from `return` here.
    let dummy = (search search-local-pkgs $rest)
    if (($dummy | length) <= 0) {
        tprint -e "No packages found matching '{rest}'!" { rest: $rest }
        return
    } else {
        print (
            $dummy
            | select index pkg version provider
        )
    }
    let which = (prompt (_ "Select which package to remove") $dummy)
    $which | each { |part|
        tprint -e "Removing '{part}' from '{provider}'" {
            part: $"(ansi purple_bold)($part.pkg | ansi strip)(ansi reset)",
            provider: $"(ansi purple_bold)($part.provider | ansi strip)(ansi reset)"
        }
    }
    let response = (input (_ "Are you sure? ({y}/{n}) " {
                y: $"(ansi green_bold)y(ansi reset)",
                n: $"(ansi red_bold)N(ansi reset)" }
        )
    )
    if not ($response | str downcase | str starts-with "y") {
        exit 1
    }
    for $part in $which {
        remove-pkg ($part.pkg | ansi strip) ($part.provider | ansi strip) $yes
    }
}

def "main c" [
    --yes (-y)
] {
    if $yes {
        main cleanup --yes
    } else {
        main cleanup
    }
}

def "main cleanup" [
    --yes (-y) # Makes functions with confirmation prompts run promptless
] {
    if not $yes {
        if not (input (_ "Attempting to repair dependencies and remove unused packages. Continue? ({y}/{n}) " {
                    y: $"(ansi green_bold)y(ansi reset)",
                    n: $"(ansi red_bold)N(ansi reset)"
                }
            )
                | str downcase
                | str starts-with "y") {
            exit 1
        }
    }
    cleanup-pkg $yes
}

def "main u" [
    --yes (-y)
] {
    if $yes {
        main update --yes
    } else {
        main update
    }
}

def "main up" [
    --yes (-y)
] {
    if $yes {
        main update --yes
    } else {
        main update
    }
}

def "main upgrade" [
    --yes (-y)
] {
    if $yes {
        main update --yes
    } else {
        main update
    }
}

def "main update" [
    --yes (-y) # Makes functions with confirmation prompts run promptless
] {
    if (not $yes) {
        let response = (input (_ "Are you sure you want to update all packages? ({y}/{n}) " {
                    y: $"(ansi green_bold)y(ansi reset)",
                    n: $"(ansi red_bold)N(ansi reset)"
                }
            ))
        if not ($response | str downcase | str starts-with "y") {
            exit 1
        }
    }
    apt upgrade $yes
    pacstall upgrade $yes
    flatpak upgrade $yes
    snap upgrade $yes
}

def "main sy" [] {
    repo-sync
}

def "main sync" [] {
    repo-sync
}
